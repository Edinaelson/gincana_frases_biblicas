using System.Net.Http;
using System.Net.Http.Json;
using System.Text.Json;
using System.Threading.Tasks;
using System.Text;
using System.Net.Http.Headers;

namespace GincanaPassagensBiblicas.Services
{
    // Dummy implementation for now. Replace with real Gemini/OpenAI integration.
    public class GeminiService : IGeminiService
    {
        private readonly HttpClient _http;
        private readonly string _apiKey;

        public GeminiService(HttpClient http)
        {
            _http = http;
            // Read API key from environment variable GEMINI_API_KEY or app settings
            _apiKey = Environment.GetEnvironmentVariable("GEMINI_API_KEY") ?? string.Empty;
        }

        public async Task<bool> AnalyzeAsync(string text)
        {
            if (string.IsNullOrWhiteSpace(_apiKey))
            {
                // fallback to simple heuristic when API key not provided
                return !string.IsNullOrWhiteSpace(text) && text.Length > 20 &&
                       (text.IndexOfAny(new char[] { 'a','e','i','o','u','A','E','I','O','U' }) >= 0);
            }

            var url = "v1beta/models/gemini-3-flash-preview:generateContent";

            var payload = new
            {
                contents = new[] {
                    new { parts = new[] { new { text = text } } }
                }
            };

            var req = new HttpRequestMessage(HttpMethod.Post, url);
            req.Headers.Add("x-goog-api-key", _apiKey);
            req.Content = new StringContent(JsonSerializer.Serialize(payload), Encoding.UTF8, "application/json");

            var resp = await _http.SendAsync(req);
            if (!resp.IsSuccessStatusCode)
            {
                // fallback
                return !string.IsNullOrWhiteSpace(text) && text.Length > 20;
            }

            var doc = JsonDocument.Parse(await resp.Content.ReadAsStringAsync());
            // Parse response to decide true/false — this is heuristic and may need adjustment.
            try
            {
                var root = doc.RootElement;
                if (root.TryGetProperty("candidates", out var candidates))
                {
                    foreach (var c in candidates.EnumerateArray())
                    {
                        if (c.TryGetProperty("content", out var content))
                        {
                            var textOut = content.GetProperty("text").GetString() ?? string.Empty;
                            // naive check: if response contains 'true' or 'válid' assume valid
                            var lowered = textOut.ToLowerInvariant();
                            if (lowered.Contains("true") || lowered.Contains("válid") || lowered.Contains("válido") || lowered.Contains("faz sentido") || lowered.Contains("makes sense"))
                                return true;
                        }
                    }
                }
            }
            catch { }

            return false;
        }
    }
}
